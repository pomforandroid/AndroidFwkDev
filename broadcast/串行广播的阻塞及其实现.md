# 串行广播阻塞
- 静态方式注册的广播会被配置成串行广播
- 系统广播增加FLAG_RECEIVER_REGISTERED_ONLY以杜绝App静态注册
- MEDIA_MOUNT广播增加FLAG_RECEIVER_REGISTERD_BEFORE_BOOT使得可以在开机完成前发送广播
- 串行广播必须等前面串行广播接收者处理完毕
- 串行广播通过binder调用到应用端接的方式是oneway，不会阻塞AMS

## 系统广播增加FLAG_RECEIVER_REGISTERED_ONLY以杜绝App静态注册
````
ActivityManagerSerivice.java
final int broadcastIntentLocked(ProcessRecord callerApp,
            String callerPackage, Intent intent, String resolvedType,
            IIntentReceiver resultTo, int resultCode, String resultData,
            Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle bOptions,
            boolean ordered, boolean sticky, int callingPid, int callingUid, int userId) {

  ...

  List receivers = null;
  List<BroadcastFilter> registeredReceivers = null;
  // Need to resolve the intent to interested receivers...
  if ((intent.getFlags()&Intent.FLAG_RECEIVER_REGISTERED_ONLY) //当系统广播增加了这个FLAG意味着不会走下面的collectReceiverComponents
           == 0) {
      receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);
  }
}
````
## MEDIA_MOUNT广播增加FLAG_RECEIVER_REGISTERD_BEFORE_BOOT使得可以在开机完成前发送广播
````
StorageManagerService.java
case H_VOLUME_BROADCAST: {
    final StorageVolume userVol = (StorageVolume) msg.obj;
    final String envState = userVol.getState();
    Slog.d(TAG, "Volume " + userVol.getId() + " broadcasting " + envState + " to "
            + userVol.getOwner());

    final String action = VolumeInfo.getBroadcastForEnvironment(envState);
    if (action != null) {
        final Intent intent = new Intent(action,
                Uri.fromFile(userVol.getPathFile()));
        intent.putExtra(StorageVolume.EXTRA_STORAGE_VOLUME, userVol);
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT
                | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
        mContext.sendBroadcastAsUser(intent, userVol.getOwner());
    }
    break;
}
````
````
ActivityManagerSerivice.java
final Intent verifyBroadcastLocked(Intent intent) {
  // Refuse possible leaked file descriptors
  if (intent != null && intent.hasFileDescriptors() == true) {
      throw new IllegalArgumentException("File descriptors passed in Intent");
  }

  int flags = intent.getFlags();

  if (!mProcessesReady) {
      // if the caller really truly claims to know what they're doing, go
      // ahead and allow the broadcast without launching any receivers
      if ((flags&Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT) != 0) {
          // This will be turned into a FLAG_RECEIVER_REGISTERED_ONLY later on if needed.
      } else if ((flags&Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
          Slog.e(TAG, "Attempt to launch receivers of broadcast intent " + intent
                  + " before boot completion");
          throw new IllegalStateException("Cannot broadcast before boot completed");
      }
  }
  ...
}
````
